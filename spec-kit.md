# 1 spec-kit 使用指南

## 1.1 概述

spec-kit 是一个标准化的软件开发流程工具，专为 AI 辅助开发设计。它将软件开发过程系统化，从需求分析到最终实现，确保每个阶段都有明确的输入输出和质量标准。

spec-kit 基于 GitHub 的 [spec-kit](https://github.com/github/spec-kit) 项目，通过结构化的工作流程帮助开发团队（包括 AI 助手）高效、规范地完成软件开发任务。

## 1.2 核心理念

### 1.2.1 阶段化开发
将软件开发分为四个明确的阶段：
- **规格阶段** (`/speckit.specify`) - 需求分析和规格定义
- **规划阶段** (`/speckit.plan`) - 技术设计和实现计划
- **任务阶段** (`/speckit.tasks`) - 任务分解和依赖管理
- **实现阶段** (`/speckit.implement`) - 代码实现和验证

### 1.2.2 用户故事驱动
- 每个功能按优先级（P1, P2, P3...）分解为独立的用户故事
- 每个用户故事都可以独立实现、测试和部署
- 支持 MVP（最小可行产品）优先的开发策略

### 1.2.3 宪法约束
通过 `constitution.md` 定义项目的核心开发原则，包括：
- 技术栈要求和约束
- 测试标准和质量门禁
- 性能目标和安全要求
- 开发流程和审查标准

## 1.3 工作流程详解

### 1.3.1 第一阶段：需求规格 (`/speckit.specify`)

**目的**：将用户的自然语言描述转换为结构化的功能规格文档

**使用方法**：
```bash
/speckit.specify "我想要添加用户认证功能，支持邮箱注册和密码登录"
```

**执行过程**：
1. **分支管理**：
   - 自动分析功能描述，生成简洁的分支名称（如：`user-auth`）
   - 检查现有分支，自动分配下一个可用编号
   - 创建并切换到新分支（如：`005-user-auth`）

2. **规格生成**：
   - 基于模板 `spec-template.md` 生成规格文档
   - 提取关键概念：参与者、操作、数据、约束
   - 定义用户场景和验收标准
   - 生成功能需求和成功标准

3. **质量验证**：
   - 创建质量检查清单
   - 识别需要澄清的问题（最多3个）
   - 确保规格完整性和可测试性

**输出文件**：
```
specs/005-user-auth/
├── spec.md              # 功能规格文档
└── checklists/
    └── requirements.md   # 质量检查清单
```

### 1.3.2 第二阶段：技术规划 (`/speckit.plan`)

**目的**：基于规格文档生成技术设计和实现计划

**使用方法**：
```bash
/speckit.plan
```

**执行过程**：
1. **技术上下文分析**：
   - 确定技术栈和依赖
   - 定义存储方案和测试策略
   - 识别性能目标和约束条件

2. **宪法合规检查**：
   - 验证设计是否符合项目宪法
   - 识别违规并提供合理解释
   - 确保复杂度得到合理控制

3. **分阶段设计**：
   - **Phase 0**：技术调研，解决所有未明确的技术选择
   - **Phase 1**：数据模型设计、API 契约定义、快速开始指南
   - **Phase 2**：更新 AI 上下文，确保技术决策得到保存

**输出文件**：
```
specs/005-user-auth/
├── plan.md              # 实现计划
├── research.md          # 技术调研结果
├── data-model.md        # 数据模型设计
├── quickstart.md        # 快速开始指南
└── contracts/           # API 接口契约
    ├── api.yaml
    └── schemas/
```

### 1.3.3 第三阶段：任务分解 (`/speckit.tasks`)

**目的**：将设计文档转换为可执行的任务列表

**使用方法**：
```bash
/speckit.tasks
```

**执行过程**：
1. **任务分析**：
   - 解析设计文档，提取技术栈和架构信息
   - 分析用户故事优先级和依赖关系
   - 映射实体、端点到对应的用户故事

2. **任务组织**：
   - **Phase 1**：项目初始化和基础设置
   - **Phase 2**：基础设施和阻塞依赖（必须先完成）
   - **Phase 3+**：按优先级顺序的用户故事实现
   - **Final Phase**：优化和跨切面关注点

3. **依赖管理**：
   - 明确任务间的依赖关系
   - 标识可并行执行的任务 `[P]`
   - 提供并行执行示例

**任务格式规范**：
```markdown
- [ ] T001 创建项目结构
- [ ] T005 [P] 实现认证中间件在 src/middleware/auth.py
- [ ] T012 [P] [US1] 创建用户模型在 src/models/user.py
- [ ] T014 [US1] 实现用户服务在 src/services/user_service.py
```

**输出文件**：
```
specs/005-user-auth/
└── tasks.md             # 详细任务清单
```

### 1.3.4 第四阶段：代码实现 (`/speckit.implement`)

**目的**：按照任务清单执行具体的代码实现

**使用方法**：
```bash
/speckit.implement
```

**执行过程**：
1. **前置检查**：
   - 验证所有检查清单是否完成
   - 确认项目忽略文件配置
   - 检查任务清单完整性

2. **分阶段执行**：
   - **设置阶段**：项目初始化、依赖安装、配置文件
   - **测试先行**：如果要求 TDD，先写测试再实现
   - **核心开发**：模型、服务、端点的实现
   - **集成工作**：数据库连接、中间件、日志等
   - **优化验证**：单元测试、性能优化、文档更新

3. **进度跟踪**：
   - 实时报告任务完成状态
   - 自动标记已完成的任务
   - 提供错误处理和恢复建议

## 1.4 项目结构

### 1.4.1 `.specify` 目录组织

```
.specify/
├── memory/
│   └── constitution.md          # 项目开发宪法
├── scripts/
│   └── powershell/              # PowerShell 自动化脚本
│       ├── create-new-feature.ps1
│       ├── setup-plan.ps1
│       ├── update-agent-context.ps1
│       └── check-prerequisites.ps1
└── templates/
    ├── spec-template.md         # 需求规格模板
    ├── plan-template.md         # 实现计划模板
    ├── tasks-template.md        # 任务清单模板
    ├── checklist-template.md    # 检查清单模板
    └── agent-file-template.md   # AI 上下文模板
```

### 1.4.2 功能文档结构

  每个功能都有独立的文档目录：

  ```
  specs/[编号-功能名]/
  ├── spec.md              # 需求规格（必需）
  ├── plan.md              # 实现计划（必需）
  ├── tasks.md             # 任务清单（必需）
  ├── research.md          # 技术调研（可选）
  ├── data-model.md        # 数据模型（可选）
  ├── quickstart.md        # 快速开始（可选）
  ├── contracts/           # API 契约（可选）
  └── checklists/          # 质量检查清单（可选）
      ├── requirements.md
      ├── ux.md
      ├── security.md
      └── test.md
  ```

## 1.5 AI 模型理解机制

### 1.5.1 结构化输入处理

AI 模型通过标准化的命令接口接收输入：

  ```markdown
  ---
  description: 命令功能描述
  ---

  ## User Input
  ```text
  $ARGUMENTS
  ```

  ## 1.6 Outline
  1. 步骤1说明
  2. 步骤2说明
  ...
  ```

这种结构确保：
- 明确的命令描述和预期行为
- 标准化的用户输入处理
- 详细的执行大纲指导

### 2. 上下文管理

**动态上下文更新**：
- 通过 `update-agent-context.ps1` 脚本自动更新 AI 上下文
- 保存技术决策、项目配置和关键信息
- 支持跨会话的上下文保持

**上下文内容**：
- 技术栈选择和版本信息
- 项目架构和设计模式
- 关键依赖和集成点
- 性能目标和约束条件

### 3. 质量保证机制

**自动化验证**：
- 检查清单自动生成和验证
- 需求澄清机制（最多3个 NEEDS CLARIFICATION）
- 宪法合规性自动检查

**错误处理**：
- 明确的错误消息和恢复建议
- 渐进式验证，避免后期才发现问题
- 支持迭代改进和反馈循环

### 4. 模板驱动生成

**标准化输出**：
- 所有文档都基于统一模板
- 确保格式一致性和内容完整性
- 支持自动化验证和质量检查

**模板特性**：
- 占位符替换机制
- 条件内容包含
- 结构化的章节组织

## 最佳实践

### 1. 需求描述技巧

**好的需求描述**：
```
我想要添加用户认证功能，支持：
- 邮箱注册和密码登录
- 密码重置功能
- 记住登录状态（可选）
- 管理员用户管理界面
```

**避免的描述**：
```
我要做个登录功能
```

### 2. 用户故事设计

**优先级分配**：
- **P1**：核心功能，MVP 必需
- **P2**：重要功能，增强体验
- **P3**：锦上添花，后期优化

**独立性原则**：
- 每个用户故事都应该可以独立测试
- 避免用户故事间的强依赖
- 支持增量交付和验证

### 3. 技术选择策略

**宪法约束**：
- 优先选择项目宪法中推荐的技术栈
- 如需偏离，必须提供充分理由
- 确保技术选择符合长期维护要求

**调研驱动**：
- 对不确定的技术选择进行充分调研
- 记录决策过程和替代方案
- 考虑团队技能和社区支持

### 4. 任务管理技巧

**并行化机会**：
- 识别可以并行执行的任务
- 合理分配开发资源
- 缩短整体开发周期

**依赖管理**：
- 明确任务间的依赖关系
- 优先处理阻塞依赖
- 避免循环依赖

## 使用示例

### 完整流程演示

假设我们要开发一个博客系统的文章管理功能：

**步骤1：需求规格**
```bash
/speckit.specify "开发博客文章管理功能，支持文章的创建、编辑、删除和发布，包含分类和标签功能"
```

**步骤2：技术规划**
```bash
/speckit.plan
```

**步骤3：任务分解**
```bash
/speckit.tasks
```

**步骤4：代码实现**
```bash
/speckit.implement
```

### 1.5.2 预期输出

**分支结构**：
```
001-blog-article-management/
├── spec.md
├── plan.md
├── tasks.md
├── research.md
├── data-model.md
├── quickstart.md
└── contracts/
    └── api.yaml
```

**任务示例**：
```markdown
## Phase 3: User Story 1 - 文章创建和编辑 (Priority: P1) 🎯 MVP

- [ ] T012 [P] [US1] 创建 Article 模型在 src/models/article.py
- [ ] T013 [P] [US1] 创建 Category 模型在 src/models/category.py
- [ ] T014 [US1] 实现 ArticleService 在 src/services/article_service.py
- [ ] T015 [US1] 实现文章创建 API 在 src/api/articles.py
- [ ] T016 [US1] 实现文章编辑 API 在 src/api/articles.py
```

## 1.6 常见问题解答

### 1.6.1 Q1: 如何处理需求变更？

**A**: spec-kit 支持迭代开发：
1. 在当前分支上更新 `spec.md`
2. 重新运行 `/speckit.plan` 更新设计
3. 重新生成 `/speckit.tasks` 调整任务
4. 继续执行 `/speckit.implement`

### 1.6.2 Q2: 可以跳过某些阶段吗？

**A**: 不建议跳过阶段，但可以：
- 使用已有的设计文档直接运行 `/speckit.tasks`
- 在实现过程中补充缺失的设计文档
- 确保每个阶段的输出质量

### 1.6.3 Q3: 如何处理复杂的多模块项目？

**A**: spec-kit 支持复杂项目：
- 在宪法中定义模块化策略
- 使用独立的功能分支管理不同模块
- 通过 contracts/ 定义模块间接口
- 合理规划用户故事的依赖关系

### 1.6.4 Q4: AI 模型如何处理技术细节？

**A**: AI 模型通过以下方式处理技术细节：
1. **模板引导**：使用结构化模板确保完整性
2. **上下文保持**：保存技术决策和配置信息
3. **渐进细化**：从高层次需求逐步细化到实现细节
4. **质量验证**：通过检查清单确保输出质量

## 1.7 总结

spec-kit 提供了一个完整的、标准化的软件开发流程，特别适合 AI 辅助开发场景。通过明确的阶段划分、结构化的文档模板和自动化的质量验证，它确保了从需求到实现的完整可追溯性和高质量交付。

对于 AI 模型而言，spec-kit 提供了：
- 清晰的执行框架和指导
- 结构化的输入输出格式
- 自动化的质量保证机制
- 支持迭代和反馈的工作流程

通过合理使用 spec-kit，开发团队可以显著提高开发效率，确保代码质量，并实现更好的项目管理和协作。
